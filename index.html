<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>P2P Chat</title>
  <style id="dynamic-style">
    body {
      font-family: sans-serif;
      background: #f8f8f8;
      color: #333;
      margin: 0;
    }

    input, textarea, button {
      font-size: 16px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    button {
      background: #f0f0f0;
      cursor: pointer;
    }

    #log {
      position: relative;
      white-space: pre-wrap;
      border-top: 1px solid #ccc;
      background: #fff;
      padding: 1rem;
      height: calc(100vh - 220px);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      margin-bottom: 5rem;
    }

    #log > div {
      margin-bottom: 1rem;
      padding: 8px;
      border-radius: 4px;
      background: #fff;
      position: relative;
    }

    .message-actions {
      position: absolute;
      right: 0;
      top: 0;
      display: none;
    }

    #log > div:hover .message-actions {
      display: block;
    }

    .reply-btn {
      background: none;
      border: none;
      color: #666;
      font-size: 12px;
      padding: 2px 6px;
    }

    .reply-btn:hover {
      color: #333;
    }

    .reply-indicator {
      font-size: 12px;
      color: #666;
      margin-bottom: 4px;
    }

    img {
      max-width: 150px;
      display: block;
      margin-top: 0.5rem;
    }

    .send {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #fff;
      border-top: 1px solid #ccc;
      padding: 1rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      z-index: 10;
    }

    .reply-box {
      width: 100%;
      padding: 8px;
      background: #f5f5f5;
      border-radius: 4px;
      margin-bottom: 8px;
      display: none;
    }
  </style>
</head>
<body>
  <h2>P2P Chat (PeerJS)</h2>

  <div class="co">
    <button id="create">Créer une connexion</button>
    <p>Ton ID : <span id="my-id">-</span></p>
  </div>

  <div class="join">
    <input id="peer-id" placeholder="ID " />
    <button id="connect">Join</button>
  </div>

  <div class="send">
    <div id="reply-box" class="reply-box"></div>
    <input type="file" id="imgInput" />
    <input id="message" placeholder="Message..." />
    <button id="send">Envoyer</button>
  </div>

  <div>
    <button id="toggle-css-editor">Modifier le CSS</button>
    <textarea id="css-editor" style="display:none;width:100%;height:150px;margin-top:1rem;"></textarea>
  </div>

  <pre id="log"></pre>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
    const myIdDisplay = document.getElementById('my-id');
    const log = document.getElementById('log');
    const messageInput = document.getElementById('message');
    const cssEditor = document.getElementById('css-editor');
    const styleTag = document.getElementById('dynamic-style');
    const replyBox = document.getElementById('reply-box');
    const username = prompt("Username ?");
    
    const connections = [];
    const userNames = new Map();
    const MAX_CLIENTS = 5;
    let peer = null;
    let replyingTo = null;

    const logMessage = (html, originalMessage = null) => {
      const div = document.createElement('div');
      
      if (originalMessage) {
        const replyIndicator = document.createElement('div');
        replyIndicator.className = 'reply-indicator';
        replyIndicator.innerHTML = `Réponse à: ${originalMessage}`;
        div.appendChild(replyIndicator);
      }
      
      div.innerHTML += html;
      
      // Add reply button
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'message-actions';
      const replyBtn = document.createElement('button');
      replyBtn.className = 'reply-btn';
      replyBtn.textContent = 'Répondre';
      replyBtn.onclick = () => {
        replyingTo = html;
        replyBox.style.display = 'block';
        replyBox.innerHTML = `Répondre à: ${html.replace(/<[^>]*>/g, '').substring(0, 50)}...`;
        messageInput.focus();
      };
      actionsDiv.appendChild(replyBtn);
      div.appendChild(actionsDiv);
      
      log.appendChild(div);
      log.scrollTop = log.scrollHeight;
    };

    const formatMessage = (text) => {
      return text.replace(/\[(#?[a-zA-Z0-9]+):([^\]]+)\]/g, (_, color, content) => {
        return `<span style="color:${color}">${content}</span>`;
      });
    };

    // CSS toggle
    document.getElementById('toggle-css-editor').onclick = () => {
      cssEditor.style.display = cssEditor.style.display === 'none' ? 'block' : 'none';
      cssEditor.value = styleTag.textContent;
    };

    cssEditor.addEventListener('input', () => {
      styleTag.textContent = cssEditor.value;
    });

    // Création d'une session
    document.getElementById('create').onclick = () => {
      peer = new Peer();
      peer.on('open', (id) => {
        myIdDisplay.textContent = id;
        logMessage(`<i>Ton ID: ${id}</i>`);
      });

      peer.on('connection', (connection) => {
        if (connections.length >= MAX_CLIENTS - 1) {
          connection.close();
          logMessage(`<i>Connexion refusée : max atteint.</i>`);
          return;
        }
        setupConnection(connection);
      });
    };

    // Rejoindre une session
    document.getElementById('connect').onclick = () => {
      const peerId = document.getElementById('peer-id').value;
      if (!peer) peer = new Peer();
      peer.on('open', () => {
        const conn = peer.connect(peerId);
        setupConnection(conn);
      });
    };

    const sendBtn = document.getElementById('send');

    sendBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      sendMessage();
    });

    sendBtn.addEventListener('click', (e) => {
      e.preventDefault();
      sendMessage();
    });

    function sendMessage() {
      const msg = messageInput.value.trim();
      if (!msg) return;
      
      const messageData = {
        type: "message",
        text: msg,
        replyTo: replyingTo ? replyingTo.replace(/<[^>]*>/g, '') : null
      };
      
      connections.forEach(c => c.send(messageData));
      
      if (replyingTo) {
        logMessage(`<b>${username}:</b> ${formatMessage(msg)}`, replyingTo);
        replyingTo = null;
        replyBox.style.display = 'none';
      } else {
        logMessage(`<b>${username}:</b> ${formatMessage(msg)}`);
      }
      
      messageInput.value = '';
      setTimeout(() => {
        messageInput.focus();
      }, 0);
    }

    // Envoi d'image
    document.getElementById("imgInput").addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result;
        connections.forEach(c => c.send({ type: "image", data: base64 }));
        const img = document.createElement("img");
        img.src = base64;
        log.appendChild(img);
      };
      reader.readAsDataURL(file);
    });
    
    function setupConnection(connection) {
      connection.on('open', () => {
        connections.push(connection);
        connection.send({ type: "username", name: username });

        connection.on('data', (data) => {
          if (data.type === "username") {
            userNames.set(connection, data.name);
            logMessage(`<i>${data.name} a rejoint la conversation</i>`);
          } else if (data.type === "message") {
            const name = userNames.get(connection) || "Inconnu";
            if (data.replyTo) {
              logMessage(`<b>${name}:</b> ${formatMessage(data.text)}`, data.replyTo);
            } else {
              logMessage(`<b>${name}:</b> ${formatMessage(data.text)}`);
            }
          } else if (data.type === "image") {
            const img = document.createElement("img");
            img.src = data.data;
            log.appendChild(img);
          }
        });

        connection.on('close', () => {
          const name = userNames.get(connection) || "Un utilisateur";
          logMessage(`<i>${name} s'est déconnecté.</i>`);
          userNames.delete(connection);
          connections.splice(connections.indexOf(connection), 1);
        });
      });
    }
  </script>
</body>
</html>